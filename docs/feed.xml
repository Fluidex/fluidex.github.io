<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fluidex</title>
  <subtitle></subtitle>
  <link href="https://www.fluidex.io/feed.xml" rel="self"/>
  <link href="https://www.fluidex.io/"/>
  
    <updated>2021-05-11T00:40:30+08:00</updated>
  
  <id>https://www.fluidex.io</id>
  <author>
    <name>Author Name</name>
    <email>author@site.com</email>
  </author>
  
    
    <entry>
      <title>Fluidex: A ZK-Rollup layer2 DEX on Ethereum</title>
      <link href="https://www.fluidex.io/posts/2020-11-30-fluidex-a-zkrollup-layer2-dex/"/>
      <updated>2020-11-29T08:00:00+08:00</updated>
      <id>https://www.fluidex.io/posts/2020-11-30-fluidex-a-zkrollup-layer2-dex/</id>
      <content type="html">
        <![CDATA[
      <h1 id="what-is-fluidex"><a class="anchor-link" href="#what-is-fluidex"></a> What is FluiDex</h1>
<p>For those familiar with cutting-edge technology, FluiDex is a Layer 2 decentralized exchange on Ethereum. We will use PLONK-based zkrollup technology to achieve high-performance transactions, while being able to reduce the cost of each transaction to less than 1% of normal L1 transaction. We will be the first order book exchange on Ethereum to use PLONK based validity proof.</p>
<p>For the general public, FluiDex is a crypto asset exchange similar to Coinbase or Huobi. The advantage is that your assets are absolutely safe. You don’t need to trust the team of the exchange to be ethical or law-abiding. You only need to trust cryptography and code. The disadvantage is that it will be more difficult to use, for example, transaction fees will be higher in some cases.</p>
<h1 id="why-build-fluidex"><a class="anchor-link" href="#why-build-fluidex"></a> Why build FluiDex</h1>
<p>“Build a safe, professional and easy-to-use digital asset trading platform&quot; is our long-term vision.</p>
<p>In the scope of technology products that exist today, “security” means Ethereum, which requires almost no explanation. I will talk about how FluiDex understands “professional trading” in the below paragraph.</p>
<p>We roughly divide the traders in the market into two categories. One category is called “speculative retail investors”. The feature is that they don’t care about miners’ fees and handling fees, and don’t care about the slippage loss of market orders. They just want to be able to easily buy certain assets. Because they bet that this asset will increase several times, the other type, we call it “professional traders”, they care about miners’ fees and handling fees, they are skilled in using derivative hedging, they can arbitrage through different exchanges, and they are skilled in using limit/market/stoploss/FOK/IOC/AON order as a tool for different purposes, may use a program to do automatic trading.</p>
<p>On today’s Ethereum, exchanges such as Uniswap based on algorithm-based automated market making have gained high popularity. Except higher miner fees, such exchanges generally meet the needs of “speculative retail investors”. However, for this type of exchange, liquidity takers can only list market price orders. For liquidity maker, there will be profit due to rebates when the price is stable, and losses when the price fluctuates sharply. The above shortcomings can be tolerated for “speculative retail investors”, but they are unimaginable for “professional traders”. For every trader with a traditional financial background, if you tell them “there is no order book, you can’t place an order for rebates; you can only place a market order, and set a slippage threshold at most”, they will be shocked.</p>
<p>We expect that more and more real assets will circulate in a decentralized manner in the future, and more and more types of traders will participate in trading. Too simple swap exchanges will not be able to meet the needs of quite a few advanced traders. The traditional order book exchange will be a much easier solution.</p>
<p>So why hasn’t the order book decentralized exchange exploded in the past few years? On the one hand, it is the ecological environment. In the early years, there were not many assets carried on Ethereum. The USDT stablecoin, which is well-known to traders, did not circulate on Ethereum two years ago. On the other hand, technology. The early and simple implementation of order book exchanges will make the cost of miners’ fees for each commission and transaction comparable to swap exchanges. Expensive order and transaction costs constrain the explosion of order book exchanges. Today Thanks to the springing up of zero-knowledge proof technology in the past two years, we are finally able to provide a trading experience with zero-cost listing orders and 0.0001$-cost transaction.</p>
<p>In summary, the development of a decentralized economy has brought more and more traders and trading needs, and order book exchanges can better meet the needs of professional traders. In the past few years, the development of cryptography technology has made it possible for high-performance, low-cost and secure order book transactions. Therefore, it is time to build FluiDex now.</p>
<h1 id="similar-products-and-projects"><a class="anchor-link" href="#similar-products-and-projects"></a> Similar products and projects</h1>
<ol>
<li>Traditional centralized exchange. For quite a few, even more than half of the people, this type of exchange is good enough to use. However, for some people who have high requirements for fund security &amp; anonymity, the hidden danger of black swan always exists in centralized exchanges. Even for a big exchange like OKEx, it happened not long ago that the exchange was unable to withdraw the coin because the founder lost contact for more than a month.</li>
<li>Algorithmic automated market making exchange. Typical is Uniswap, which sets the price of buying and selling assets by always ensuring that the number of asset A * the number of asset B == the fixed value. In the previous paragraph, we believe that such exchanges are not enough for professional traders. But it must be acknowledged that the composability of such swap exchanges is an advantage that Layer2 DEX does not have, and Layer2 DEX is more difficult to become part of the “Defi building block”.</li>
<li>Order book exchange based on optimistic rollup technology. This type of exchange has high performance and is easy to develop, but it has two major disadvantages. The first is that withdrawing from such exchanges requires confirmation time of weeks, which is completely unacceptable for many traders. Second, the security of optimistic rollup is not as good as “as safe as L1” zk rollup.</li>
<li>Other products with similar technical decisions, such as diversifi and loopring. Yes, in a nutshell, FluiDex will compete head-to-head with them. That there are already one or two players in a potential big market, is not a reason why new players should not enter. It is not true that since OKEx is running well, Binance should not start a business. In addition, FluiDex and these projects will have some different decisions both in technology and product. For example, from a technical perspective, we will use PLONK as the protocol of zero-knowledge proof, which will bring faster product iteration, from a product perspective, we are likely to implement permissionless token listing.</li>
</ol>
<h1 id="decentralized-governance-%26-token"><a class="anchor-link" href="#decentralized-governance-%26-token"></a> Decentralized Governance &amp; Token</h1>
<p>I believe that our exchange is a traditional “centralized” exchange, the only difference is the self-custody of assets. There are many interpretations of “decentralization”, the decentralization of assets, the decentralization of control (“governance”), and even the decentralization of teams. Based on our vision, the decentralization of assets (ie, the self-custody of assets) is necessary for us. But, at least today, we believe that decentralization of governance is neither necessary nor sufficient for building a great product. Any team that does a product will investigate users and markets, but no team will decide the future of product only through user votes. Customers and shareholders are two kinds of people. You should not force or expect customers to become shareholders. For the FluiDex team, the customer is supreme, but there will be no so-called “decentralized” governance in the future. The decision-making power of the future of the product will always be in the hands of the management team, and users are expected to vote for our success or failure with their feet.</p>
<p>Based on our understanding of governance philosophy above, FluiDex will not issue “governance tokens” in the foreseeable future, but we are not opposed to issuing tokens with dividend rights for fundraising. For example, it is entirely possible for us to issue a token and guarantee to buy back this token with 10% of the monthly gross profit for the next 3 years.</p>
<h1 id="project-status-%26-schedule-%26-financing"><a class="anchor-link" href="#project-status-%26-schedule-%26-financing"></a> Project status &amp; schedule &amp; financing</h1>
<p>Fluidex project was launched at the end of 2020. It is expected that the MVP/demo will be completed in Q2 of 2021, and the mainnet launch will probably start in Q4 of 2021.</p>
<p>Update 2021.04.15:<br>
The project may soon launch a seed round of equity financing, and is looking for raising a total amount of around US$1 million, at a valuation of US$7-10 million, from all participating investors.</p>
<h1 id="contact"><a class="anchor-link" href="#contact"></a> Contact</h1>
<p>Telegram: <a href="https://t.me/fluid_dex">https://t.me/fluid_dex</a><br>
Medium: <a href="https://fluid-dex.medium.com/announcing-fluidex-building-the-first-plonk-layer2-dex-on-ethereum-e19136304a5d">https://fluid-dex.medium.com/announcing-fluidex-building-the-first-plonk-layer2-dex-on-ethereum-e19136304a5d</a><br>
Twitter: <a href="https://twitter.com/fluid_dex">https://twitter.com/fluid_dex</a><br>
Founder’s email: <a href="mailto:mycinbrin@gmail.com">mycinbrin@gmail.com</a></p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Fluidex Recent Updates</title>
      <link href="https://www.fluidex.io/posts/2021-03-04-recent-updates/"/>
      <updated>2021-03-03T08:00:00+08:00</updated>
      <id>https://www.fluidex.io/posts/2021-03-04-recent-updates/</id>
      <content type="html">
        <![CDATA[
      <p>About us: The Fluidex team is developing the first zk-rollup layer2 order-book DEX with permissionless listings on Ethereum. For a more comprehensive introduction to the project, please see <a href="/posts/2020-11-30-fluidex-a-zkrollup-layer2-dex/">our previous article</a>.</p>
<p>In this post, We are happy to explain what we have achieved since the early 2021, at what time the project was launched.</p>
<h1 id="technical-progress"><a class="anchor-link" href="#technical-progress"></a> Technical progress</h1>
<h3>Plonkit</h3>
<p>As the saying goes, good tools are prerequisite to the success of a job.</p>
<p>Plonkit is a PLONK zero-knowledge proof toolkit developed by the Fluidex team. By using Plonkit, users can use an easier DSL (Circom) to implement their own zero-knowledge proof circuit code, without the need to learn the underlying cryptography library and how to write circuits in C or Rust (which is way more complicated).</p>
<p>The core of Plonkit is developed based on the bellman_ce cryptography library. The current functions include local setup (for development use only, in production better to use MPC ceremony), circuit proving and verification, solidity verification contract generation, etc.</p>
<p>Plonkit has received a lot of attention from developers since being open sourced, and it is now the project with the most stars on github by the team.</p>
<p>We are implementing server mode so that plonkit can serve for continuously-running proving service. In the future, we will further implement the cluster proving server feature. In a longer term, we may add custom gates to further improve the performance of the system. In addition, we will continue to improve DSL specifically for PLONK and its variants.</p>
<p>For more, please visit github: <a href="https://github.com/Fluidex/plonkit">https://github.com/Fluidex/plonkit</a></p>
<h3>Exchange</h3>
<p>In the past a few months, the Fluidex team has finished the first version of the exchange matching engine backend and web frontend. The backend of the matching engine has been open sourced, using Rust language to implement in-memory order matching, which can achieve thousands of TPS. This will ensure the fluency and stability of our trading system in the foreseeable future.  We are still improving this system continuously. (It hasn’t been tempered by real business, so it is only recommended to be used only for learning and communication at present rather than production).</p>
<p>Currently, the back end of the exchange has been open sourced, and the front end has not yet been open sourced.<br>
For more details, please visit github: <a href="https://github.com/Fluidex/dingir-exchange">https://github.com/Fluidex/dingir-exchange</a></p>
<h3>Zero-knowledge proof circuit and smart contract</h3>
<p>We have delivered <a href="https://github.com/Fluidex/rescue-hash-js">the first implementation of Javascript Rescue Hash</a>, and also developed <a href="https://github.com/Fluidex/circuits/blob/master/src/lib/rescue.circom">the first circom implementation of Rescue Hash circuit</a>. Based on the Echarts sunburst chart, we have developed <a href="https://github.com/Fluidex/circuits/blob/master/tools/benchmark/profile_circuit.js">a tool for profiling circuits visually</a>. So users can analyze their own circuit code more conveniently, finding which parts of the circuits lead to the major computation overhead, so they can make further optimization accordingly.</p>
<p>We have prototyped the most basic circuit code for deposit, withdrawal &amp; transfer &amp; trading. There are still many functions and performance details that need to be further improved, so we will not introduce it for the time being. Of course, all the code is at a very early stage, without any audit, it is not recommended for production use.</p>
<p>All the above results have been open sourced in our code base. For more details, please visit github: <a href="https://github.com/Fluidex/circuits">https://github.com/Fluidex/circuits</a></p>
<h3>Awesome Plonk</h3>
<p>This is a collection of high-quality materials about PLONK. It covers various learning materials such as papers, implementations, demos, forums, blog posts, videos, etc.</p>
<p>For more details, please visit github: <a href="https://github.com/Fluidex/awesome-plonk">https://github.com/Fluidex/awesome-plonk</a></p>
<h1 id="community-status"><a class="anchor-link" href="#community-status"></a> Community Status</h1>
<p>Currently we only maintain the English technical community on Telegram. More than 100 developers who are interested in our project have joined in the past two months. In the future, we will continue to update our technological progress there.</p>
<h1 id="financing-status"><a class="anchor-link" href="#financing-status"></a> Financing status</h1>
<p>In the past few months, Fluidex has raised a total of more than US$500,000 from several private investors. We would like to thank these seniors in the industry for their financial and other support.</p>
<p>The money is sufficient for our current development. We are not seeking further financing for the time being.</p>
<h1 id="technical-contribution-to-other-projects"><a class="anchor-link" href="#technical-contribution-to-other-projects"></a> Technical contribution to other projects</h1>
<p>We found a <a href="https://github.com/matter-labs/zksync/pull/284">bug when the number of inputs is greater than 1</a>, in the open sourced PLONK solidity verification contract code of Matters Lab, and submitted an upstream pull request. (The zksync online system does not trigger this code path, and the correctness and safety are not affected by this bug.)</p>
<p>Fluidex is participating into the phase 2 trusted setup ceremony of the Hermez project, hoping to contribute to the wider Layer2 community through its own strength. (Explanation: What is the “phase 2 trusted setup ceremony”? The zk-rollup projects that use Groth16 protocol need to ensure the security of some cryptographic parameters by using multi-party computations. The “phase 2 trusted setup ceremony” is one of such multi-party computations. As long as at least one of the participants is honest, the entropy and hence randomness can be guaranteed. Provers then cannot forge a proof.)</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>ZK-Rollup development experience sharing, Part I</title>
      <link href="https://www.fluidex.io/posts/zkrollup-intro1/"/>
      <updated>2021-05-11T00:40:30+08:00</updated>
      <id>https://www.fluidex.io/posts/zkrollup-intro1/</id>
      <content type="html">
        <![CDATA[
      <p><em>Acknowledgement: we would like to thank barryWhiteHat, Koh Wei Jie for their insightful feedbacks.</em></p>
<p>Prerequisites: basic programming and blockchain knowledge, no cryptography background needed.</p>
<p>Currently, major expectations on blockchain technology are further scaling, higher performance and lower costs. In this post, we will dive into ZK-Rollup, which is one of the <a href="https://ethereum.org/nl/developers/docs/layer-2-scaling/">Ethereum layer 2 scaling solutions</a>. It exquisitely applies a zero knowledge proof technique (known as ZK-SNARK) to reduce the on-chain costs, and thus, is able to improve Ethereum TPS considerably (~10x-100x). ZK-Rollup is considered as the most important Ethereum Layer 2 scaling solution in the long term by many people, including Vitalik, the founder of Ethereum.</p>
<blockquote>
<p>In general, my own view is that in the short term, optimistic rollups are likely to win out for general-purpose EVM computation and ZK rollups are likely to win out for simple payments, exchange and other application-specific use cases, but in the medium to long term ZK rollups will win out in all use cases as ZK-SNARK technology improves. – Vitalik</p>
</blockquote>
<p>In this series of posts, we will share our experience on developing a ZK-Rollup system. The motivation of these posts is that, currently there are many high quality resources introducing the cryptography behind ZK-SNARK, with a lot of math details. In the meantime, there are also many non-technical blogs looking into the impact and prospect of ZK-Rollup. Very few will dive into questions like, how does ZK-Rollup boost performance exactly? Or, how does a complete ZK-Rollup system look like? Or, is there any important but usually overlooked details in a ZK-Rollup system?</p>
<p><a href="https://github.com/Fluidex/">Fluidex</a>, as one of the very few teams that are independently developing a ZK-Rollup system from scratch, is happy to share some experience gained from ZK-Rollup system development. We hope this could benefit other developers in the field. We will talk about some important but rarely mentioned topics, like where the performance bottleneck is in a ZK-Rollup system, where does the economic cost lie, etc.</p>
<h2>Overview of ZK-SNARK &amp; ZK-Rollup</h2>
<p>Again, we won’t focus on the cryptographic details of ZK-SNARK proof, because as stated, there are enough high quality resources explaining it. In this chapter, we will briefly answer the following questions: What can ZK-SNARK do? Why does it become the core of ZK-Rollup, and help boost Ethereum performance along with “rollup”? What does “rollup” mean exactly?</p>
<h3>The Nature of ZK-SNARK</h3>
<p>Generally speaking, in a blockchain ecosystem, each node will execute the same computation for each transaction in the block, then verify that their results are the same as those of other nodes. In other words, for each transaction to be on chain, it will be executed by every node. That’s one major reason why blockchain have relatively low performance.</p>
<p>However, is “computing again” the only way to verify a transaction? To put it differently: is it necessary that the cost of verifying is as much as the cost of computing?</p>
<p>The answer is NO. Verifying could be cheaper than computing. Let’s take Sudoku for example. The complexity of solving a Sudoku is quite different from that of verifying a Sudoku solution. To “compute again” is the least efficient verification method. If you happen to have a computer science background, just consider the P vs NP problems in computational complexity theory.</p>
<p>Therefore, in blockchain, it’s worthwhile to have a technical solution that can lower the verification cost, even by increasing the computation cost. The reason is that, for each transaction, computation will only happen once, while verification will happen on every node. <strong>ZK-SNARK by nature is such a technique that significantly lowers the verification cost.</strong> Generally, ZK-SNARK can make the verification cost several orders of magnitude less than the computational cost. To be precise, reducing the verification complexity from linear to constant (or logarithmic), that is what “succinctness”, the “S” in “SNARK”, stands for.</p>
<p>Let’s look at how ZK-SNARK works.</p>
<p>For a particular program, it will first be preprocessed. After the one-off preprocessing, for each input, a prover will need to compute the result corresponding to the input, as well as generate a “proof” (usually in form of big integers) with relatively larger costs. Any verifier could use this “proof” and input to quickly verify the correctness of the result without actually running the program.</p>
<p>A more detailed description in pseudo code:</p>
<pre class="language-js"><code class="hljs language-js"><span class="token comment">// here is the the application code</span><br><span class="token comment">// it is usually called 'circuit code'</span><br><span class="token keyword">function</span> <span class="token function">some_function</span><span class="token punctuation">(</span><span class="token parameter">inputs</span><span class="token punctuation">)</span><span class="token operator">:</span><br>   <span class="token comment">// no global vars allowed here</span><br>   outputs <span class="token operator">=</span> <span class="token function">some_calculation</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><br>   <span class="token keyword">return</span> outputs<br><br><br><span class="token comment">// preprocessing only runs once for every 'some_function'</span><br><span class="token comment">// we deliberately ignore 'setup' here to make it easier for understanding</span><br><span class="token comment">// for a more precise and detailed description, you can have a look at the references at the end of this article</span><br><span class="token keyword">const</span> preprocess_result <span class="token operator">=</span> <span class="token function">zksnark_preprocess</span><span class="token punctuation">(</span>some_function<span class="token punctuation">)</span><br><span class="token keyword">const</span> verification_key <span class="token operator">=</span> preprocess_result<span class="token punctuation">.</span>verification_key<span class="token punctuation">;</span><br><span class="token keyword">const</span> proving_key <span class="token operator">=</span> preprocess_result<span class="token punctuation">.</span>proving_key<span class="token punctuation">;</span><br><br><span class="token comment">// for every 'inputs', generate 'proof'. The following codes run off chain</span><br><span class="token comment">// we deliberately ignore 'witness' here to make it easier for understanding</span><br><span class="token comment">// we will make more explanation on what consists of inputs/outputs of a realworld ZK-Rollup system in the following sections</span><br><span class="token keyword">const</span> outputs <span class="token operator">=</span> <span class="token function">some_function</span><span class="token punctuation">(</span><span class="token parameter">inputs</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// the 'prove' will need a lot of computing resource to finish</span><br><span class="token keyword">const</span> proof <span class="token operator">=</span> <span class="token function">zksnark_prove</span><span class="token punctuation">(</span>proving_key<span class="token punctuation">,</span> input<span class="token punctuation">,</span> output<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// verify the input/output is correct</span><br><span class="token comment">// The following codes usually run on chain</span><br><span class="token keyword">const</span> is_correct <span class="token operator">=</span> <span class="token function">zksnark_verify</span><span class="token punctuation">(</span>verification_key<span class="token punctuation">,</span> input<span class="token punctuation">,</span> output<span class="token punctuation">,</span> proof<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">assert</span><span class="token punctuation">(</span>is_correct <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3>Real-world Design of a Rollup System</h3>
<p>In a normal Rollup system, we will maintain a global merkle tree. All states in the Rollup system (including the balance of each token of the account, nonce of the account, etc.) will become a leaf node on the tree.</p>
<p>ZK-SNARK will guarantee mathematically that every update to the merkle tree satisfies some “predetermined rules”. Those rules are determined by the ZK-Rollup developers’ settings. For example, for a ZK-Rollup transfer system, the developers could demand that:</p>
<ol>
<li>Transfer amount is less than the balance of the sender account;</li>
<li>The signature of the sender account is valid, and nonce is correct;</li>
<li>The amount reduced in the sender account equals the amount increased in the receiver account.</li>
</ol>
<p>Additionally, the hash of the merkle root will be computed from the new leaf.</p>
<p>To guarantee security in the worst case (that is, even if the operators of the Rollup system run off, users can still withdraw their assets in one piece), the system should make sure users are able to rebuild the tree from scratch (known as “data availability”), and are able to make assertions  like “Alice actually has 3 ETH in this tree” by merkle proof. To achieve this, the system should make the data of each transaction public, and stored on chain.</p>
<p>For a batch of hundreds or thousands of transactions, after we executed them in a particular order and updated the merkle tree, we will use ZK-SNARK to prove the correctness of the result (i.e., the new root of the merkle tree). Note that the number of transactions here is determined by a predefined config, which is fixed during runtime. This batch of transactions will be proved and verified together, known as a “L2 Block”.</p>
<p>Again, let’s use pseudo code to demonstrate the data flow in a real-world ZK-Rollup system:</p>
<pre class="language-js"><code class="hljs language-js"><span class="token comment">// the following code runs as smart contract</span><br><span class="token comment">// 'global_merkle_tree_root' is the only state needed to be stored inside smart contract</span><br><span class="token keyword">let</span> global_merkle_tree_root <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> verification_key <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span><br><span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// set global_merkle_tree_root and verification_key</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">function</span> <span class="token function">verify_txs</span><span class="token punctuation">(</span><span class="token parameter">proof<span class="token punctuation">,</span> txs<span class="token punctuation">,</span> old_merkle_root<span class="token punctuation">,</span> new_merkle_root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>   <span class="token function">assert</span><span class="token punctuation">(</span>old_merkle_root <span class="token operator">==</span> global_merkle_tree_root<span class="token punctuation">)</span><span class="token punctuation">;</span><br>   <span class="token comment">// in fact we will hash of txs/old_merkle_root/new_merkle_root as a single input to 'zksnark_verify' for performance. We will not discuss this detail here as it does not block understanding</span><br>   <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">zksnark_verify</span><span class="token punctuation">(</span>proof<span class="token punctuation">,</span> txs<span class="token punctuation">,</span> old_merkle_root<span class="token punctuation">,</span> new_merkle_root<span class="token punctuation">)</span><span class="token punctuation">;</span><br>   global_merkle_tree_root <span class="token operator">=</span> new_merkle_root<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>We can see that apart from the merkle root, the contract won’t store any states. For every state update, it needs the off-chain module to prepare the complete transaction input and proof. For those who are familiar with Stateless Ethereum, ZK-Rollup is actually very similar to Stateless Ethereum in this way.</p>
<h2>System Architecture of ZK-Rollup</h2>
<p>One ZK-Rollup system needs at least the following modules:</p>
<ol>
<li>Smart Contract on Chain:</li>
</ol>
<ul>
<li>To verify the validity of each merkle tree update, and maintain the correct merkle tree root;</li>
<li>In a situation where Rollup system is down, to make sure users are able to withdraw their rightful assets by directly calling the contract;</li>
<li>To coordinate between L1 and L2, ensuring users’ deposits can be processed in time and updated into the merkle tree.</li>
</ul>
<ol start="2">
<li>Prover Cluster: To do immense cryptographic calculations to generate ZK-SNARK proof for each L2 Block. Usually a large-scale cluster is required, which consumes more than 99% of the computing resources in the system.</li>
<li>State Manager: To maintain the complete merkle tree. For each transaction, it updates the merkle tree and provides necessary data for Prover Cluster (e.g., merkle proof).</li>
<li>Other Business Modules: like a L2 browser. Besides, each Rollup system has their own specialized business modules. For example, Fluidex has a <a href="https://github.com/Fluidex/dingir-exchange">order matching engine</a>, which generates matched transactions from users’ orders, then sends them to the State Manager.</li>
</ol>
<h2>TPS limit of ZK-Rollup</h2>
<p>What is the main constraint on TPS of a ZK-Rollup system?</p>
<h3>Speed of proving</h3>
<p>Proving is the most resource consuming part of a ZK-Rollup system. Those who are new to ZK-Rollup usually mistakenly believe that speed of proving is the main constraint on TPS. Actually, as the proving of each L2 Block can be done completely in parallel, using a prover cluster with size of hundreds is a common practice. Therefore, although ZK-SNARK proofs do take long, it will mostly lead to a longer latency of withdrawing from L2 to L1, as well as a higher server cost for operators, but not a limitation on TPS.</p>
<h3>Recording data on-chain and ETH GAS limitations</h3>
<p>Well this is a real constraint on TPS. Let’s look back at the overall ZK-Rollup design. To ensure security/data availability, each layer-2 transaction should be recorded on chain. This part of data will be recorded in ETH transaction history as CALLDATA, with an average cost of 16 gas/byte. For a normal transfer/matched order, each transaction is estimated to be 40 bytes.</p>
<p>Let’s try estimating the TPS limit by gas limitations.</p>
<p>It takes ~13s for each ETH block to be mined, with maximum gas of 12.5 Million. Suppose a ZK-SNARK verify costs 0.3-0.5 Million gas, then each ETH block could contain at most 12,000,000 / (40*16) ~= 20,000 transactions. So in this way, the TPS limit of ZK-Rollup would be 1500-2000. This is also the performance upper-bound claimed by many Rollup systems in whitepapers.</p>
<h3>Global state update on Merkle Tree</h3>
<p>This is a rarely discussed but crucial perspective. <strong>The TPS of a real-world ZK-Rollup system is actually more limited by this module, rather than proving speed or gas limitations discussed above</strong>.</p>
<p>To support a large number of users and assets, we need the Merkle Tree to have a certain depth. Assuming we are using a binary dense account_balance merkle tree as follows, and we intend to support 1 Million users and 1000 types of assets, then the depth of the merkle tree is required to be 30. Suppose each transaction will cause updates on 5-10 leaf nodes, then there’ll be ~200 hash calculations in total.</p>
<p><img src="/images/account_merkle_tree.png" alt=""></p>
<!-- 
_(In a transfer-oriented zkRollup, You could indeed combine account leaf and token leaf to reduce the merkle tree depth. However, for building a DEX a account_balance tree might still be more preferable, and since we are focusing on discussing the performance on updating the merkle tree, without the loss of generality, it's fine to discuss the model as account_balance tree here.)_
 -->
<p>For performance considerations, we won’t use normal hash like SHA3 in a ZK-Rollup merkle tree. Instead, we’ll use a more ZK-SNARK compatible one like poseidon or rescue. According to <a href="https://github.com/Fluidex/state_keeper/blob/a80c40015984886b68a295a810c64a682ba13135/src/types/merkle_tree.rs#L326">test results from Fluidex</a>, each poseidon hash takes about 30us (tree depth of each test is 20, thus, each hash would be 57ms / 100 / 20 ~= 30us). So estimating from merkle tree perspective, the limit of a ZK-Rollup system would be 1 / 0.00003 / 200 = 160 TPS.</p>
<p>Therefore, <a href="https://github.com/Fluidex/state_keeper/blob/a255043cbe7c899c6a8d9cc46b170a40f20623c9/src/types/merkle_tree.rs#L127">parallel updating</a> on the merkle tree is essential to break through the 100-300 TPS level. Unlike computing ZK-SNARK proofs, which could be parallelized completely, to parallelize merkle tree updates requires more discretion, and is very hard to apply distributed computing on it. This is also a technical challenge.</p>
<p>The 100-300 TPS calculated above is close to many real-world ZK-Rollup system’s actual performance upper-bound.</p>
<h2>Economic Cost Analysis</h2>
<h3>ZK-Rollup normally needs thousands of CPU cores for proving</h3>
<p>Let’s still take <a href="https://github.com/fluidex/awesome-plonk">PLONK</a> <a href="https://github.com/Fluidex/circuits">circuits</a> used by Fluidex as a typical ZK-Rollup case. In our latest test, for each L2 Block with 100 transactions, it takes ~20min to run a proof on a 24 core server. To reach 100 TPS performance, we will need ~300 EC2 c5.12xlarge instances, which costs ~500 USD/h. This means each Layer 2 transaction will cost 0.001 USD in off-chain calculations. Note that we haven’t invested a lot on performance optimization yet, we expect there’ll be a lot to improve here in the future.</p>
<h3>On-chain gas cost much higher than off-chain server cost</h3>
<p>The cost of off-chain calculations mentioned above is actually a drop in the bucket compared to the on-chain GAS cost. Assuming each Layer 2 transaction needs 40 bytes of on-chain data, ETH is ~2000 USD, GAS price is 200 Gwei, then the cost of each transaction on-chain is ~2.6USD. This is much higher than the 0.001 USD off-chain. However, this is also much lower than a complex Layer 1 transaction, where GAS cost is normally tens of USD. That’s why we often say ZK-Rollup could bring at least two orders of magnitude cost saving.</p>
<h3>Low cost-efficiency Cloud GPU services</h3>
<p>Many developers might wonder what GPU could bring to computing power. In ZK-SNARK proving, GPUs could accelerate computing by ~3x-5x. But on the other hand, due to immaturity of virtualization, GPU from cloud services are disproportionately expensive compared to the cost of CPU. Such that there are even cases where <a href="https://minimaxir.com/2017/07/cpu-or-gpu/">CPU is cheaper than GPU</a> in deep learning model training. Therefore, if you are not building your own data center but using cloud services, using GPU for ZK proofs would be a low marginal utility choice.</p>
<p>Of course, all the above analysis data will be affected by system efficiency and ETH GAS price, but unlikely to deviate in orders of magnitude in a foreseeable future.</p>
<h2>Miscellaneous development experience</h2>
<h4>Why are ZK-SNARK logic descriptions called “circuits”?</h4>
<p>For anyone with software engineer experience, in the following code, only one of the if- branch and else- branch will be executed, rather than both executed and only one chosen.</p>
<pre class="language-js"><code class="hljs language-js"><span class="token keyword">function</span> <span class="token function">binaryOp</span><span class="token punctuation">(</span><span class="token parameter">op<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token string">"add"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> arg1 <span class="token operator">+</span> arg2<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token comment">// assert(op == 'mul');</span><br>    <span class="token keyword">return</span> arg1 <span class="token operator">*</span> arg2<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>Such concept that “only one conditional branch will be executed” seems natural for software development, but it’s not the case for the design of hardware chip circuits. In development of sequential logic circuits in hardware, logics of all “branches” (if still called “branch”) will be executed at the time the sequence is triggered. The developer needs to choose and maintain correct global states from different “branches”.</p>
<p>In a ZKP system, program logic will eventually be converted into some immense polynomials (probably with hundreds of millions of terms), which is called arithmetization, such that proving of the program will be converted to proving of the polynomials. The polynomials are then constrained in the form of gate circuit. That’s also one of the reason why we call ZKP programs as circuits. Thus, the code has the same property as hardware circuits: code from all branches will be executed together. That’s why ZK proof code is called “circuits”. In addition, similar to hardware circuits, there are no recursion and complex loops in the ZK proof circuits, and the number of loops can only be constant (actually, loops will be unrolled as syntactic sugars, i.e., loop unrolling).</p>
<p>Therefore, when developing ZK proof circuits, developers need to reconsider their habits from software development. For example, when optimizing softwares, we could focus on the most frequently executed branch, and deprioritize the non-frequent ones. But in ZK proof circuits, as all branches will be executed, the non-frequent branches need to be considered as well.</p>
<h3>Opinions on DSL</h3>
<p>There are several choices for ZK proof circuit development, such as low-level computing libraries like <a href="https://github.com/HarryR/ethsnarks">ethsnarks</a> / <a href="https://github.com/zkcrypto/bellman">bellman</a>, or DSL like <a href="https://github.com/Zokrates/ZoKrates">ZoKrates</a> / <a href="https://github.com/iden3/circom">Circom</a> / <a href="https://github.com/matter-labs/zinc">Zinc</a>.</p>
<p>We chose Circom, which provides a just right level of abstraction. On the one hand, it improves the efficiency of reading/writing code, on the other hand, it doesn’t distort the details of the underlying circuits.</p>
<p>In comparison, developing with ethsnarks and bellman is of lower efficiency. Also, when the code is being reviewed, no matter internally or externally, too much “syntactic noise” prevents the reviewer from focusing on the core logic. Additionally, ZoKrates and Zinc provide a too high level of abstraction. For example, python-style control flow syntax in ZoKrates conceals the underlying circuits, and is not conducive to lower level optimizations (such as inline assembly of C/Rust).</p>
<p>As an analogy,  ethsnarks / bellman is like assembly language in traditional development, while cirom is like C, and ZoKrates is like Python. However, ZoKrates toolchain is not as mature as Python interpreter. That’s why we’d rather use “C” (cirom in this case) as the our development language, instead of maintaining both “Python” (ZoKrates in this case) code and “CPython interpreter” (ZoKrates interpreter in this case) code.</p>
<p>However, Circom is essentially still a R1CS DSL. Fluidex actually uses PLONK proof system. We probably would make major changes on Circom to better utilize PLONK, including supports for custom gate, plookup, aggregation &amp; recursion, etc.</p>
<h2>Further Readings</h2>
<h3>Techinical Blogs</h3>
<ul>
<li><a href="https://vitalik.ca/general/2021/01/05/rollup.html">vitalik blog on rollup</a></li>
<li><a href="https://vitalik.ca/general/2021/01/26/snarks.html">vitalik blog on ZK-SNARK</a></li>
<li><a href="https://docs.ethhub.io/ethereum-roadmap/ethereum-2.0/stateless-clients/">Stateless Ethereum</a></li>
</ul>
<h3>Projects</h3>
<p>ZK-Rollup projects launched:</p>
<ul>
<li><a href="https://github.com/matter-labs/zksync">zksync</a>: the most complete open source code of ZK-Rollup, containing all modules for a ZK-Rollup system. It uses PLONK protocol, bellman for circuits, and Rust for off-chain code.</li>
<li><a href="https://github.com/hermeznetwork/">hermez</a>: similar to zksync. It uses Groth16 protocol, Circom for circuits, and Go for off-chain code.</li>
<li><a href="https://github.com/Loopring/protocols/tree/master/packages/loopring_v3">loopring</a>: only has circuit code and contract in open source. It uses Groth16 protocol, ethsnark for circuits. Off-chain code is not open sourced yet.</li>
</ul>
<p>ZK-Rollup projects under developing:</p>
<ul>
<li><a href="https://github.com/Fluidex">fluidex</a>: circuits, state manager, and matching engine in open sourced. It uses PLONK protocol, circom for circuits, and Rust for off-chain code.</li>
</ul>
<p>Non ZK-Rollup projects that use ZK-SNARK:</p>
<ul>
<li><a href="https://github.com/appliedzkp/maci/">MACI</a></li>
<li><a href="https://github.com/tornadocash">Tornado Cash</a></li>
</ul>
<h2>About Us</h2>
<p>We are the development team of <a href="https://www.fluidex.io/posts/2020-11-30-fluidex-a-zkrollup-layer2-dex/">Fluidex: A Layer 2 ZK-Rollup DEX on Ethereum</a>.</p>

    ]]>
      </content>
    </entry>
  
</feed>
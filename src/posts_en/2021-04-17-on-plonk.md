---
title: "浅谈提升 PlonK"
description: ""
category:
tags: []
---

## The 3 layers of a Proof System

+ Aggregation layer
+ Interactive oracle proofs (IOP) layer (where PlonK is)
+ Polynomial commitment layer

Readers can get an ideas on the relationships between each layers from https://electriccoin.co/blog/explaining-halo-2/ (though it's about Halo 2, it's still helpful for understanding the relationships), so we would like to skip repeated explanations here.

![](https://electriccoin.co/wp-content/uploads/2020/09/Halo-puzzle-03-scaled.jpg)
Image source：https://electriccoin.co/blog/explaining-halo-2/


## The origin of PlonK

Out of the desire for a universal, programmable SNARK, [AZTEC](https://aztec.network/) invents and promotes the usage (__TODO:__ industry...) of [PlonK](https://eprint.iacr.org/2019/953.pdf).
Vitalik also wrote an awesome article explaning PlonK: [Understanding PLONK](https://vitalik.ca/general/2019/09/22/plonk.html). You may also find some useful resources on https://github.com/Fluidex/awesome-plonk.

PlonK has been popular since it went published. [zkSync](https://zksync.io/), [Dusk Network](https://dusk.network/), [Mina](https://minaprotocol.com/)、[Mir](https://mirprotocol.org/) are projects using  PlonK or its variants.


## The features of PlonK

Universal and updateable setup 已是老生常谈，此处不再赘述。

Groth16 等 non-universal 的 proof system 中使用 rank-1 constraint system (R1CS)，也就是一堆线性的加法乘法，作为 intermediate representation 来对电路进行抽象表示。R1CS 对这些协议很高效，但对于 universal 的协议（比如 PlonK）则并不高效。PlonK 中使用的是 gate 的概念。

所以如果从 R1CS 到 PlonK 则不能很好地发挥 PlonK 的性能，最好能通过 gate 来实现 PlonK 中的约束。


## Optimizing PlonK on the IOP layer

在此基础上，PlonK 的性能还有提升的空间。

如果使用了 custom gate，就可以自定义 bit arithmetic operations，包括 EC point addition、Poseidon hashes、Pedersen hashes、8-bit 逻辑异或。这一切运算会变得很高效。可以将 custom gate 理解为小 gadget。

[PLookup](https://eprint.iacr.org/2020/315.pdf) (PlonK with lookup table) 找到了一种方式在 PlonK 的电路中高效实现 lookup table （的访问）。然后就可以构建 dynamic memory，对需要使用 vectors、dynamic array 的场景极为有利。

简单的理解就是，SNARK 本身对于位运算并不友好：你需要一个个 bit 地操作。但 lookup tables 就可以解决这个问题：你不必再每一位每一位地运算，你可以比如说将你的 8-bit 的计算结果储存在一个大表中进行查找，这样就可以一次运算 8-bit 而不必每一 bit 每一 bit 地运算。

由于这个原因，lookup tables 可以用来改善原本是 SNARK-unfriendly 的计算。

AZTEC 的 Turbo-PlonK 就是在 PlonK 的基础上加上 custom gate，然后再在此之上实现 PLookup 就是 AZTEC 的 Ultra-PlonK。


## Recursive Proof

Recursive-SNARK 的良好特性也被人注意到，越来越多协议想要使用。Recursion 这一特性应该可以认为是从 [Halo](https://eprint.iacr.org/2019/1021.pdf) 中开始发展起来的。

PlonK 对于想要改造并使用 Halo-style recursion 其实也挺友好，因为可以用 custom gate 来做 Halo 中的 prime field operations（质数域算术运算）。

但值得注意的是，Ethereum 目前支持的/将来将要支持的 pairing-friendly curve（BN254, BLS12-381...），都不是 Halo-friendly 的。这将导致 verify 时的 gas 耗费过高。

This is an optimization technique on aggregation layer.

## Optimization on Polynomial commitment layer

[SHPLONK](https://eprint.iacr.org/2020/081.pdf) is an optimization on polynomial commitment layer, and work with Plonk, to acheive smaller proof size and shorter proving time.


。别的一些论文也有对 polynomial commitment 进行的优化。但他们的问题是，他们需要的 cryptographic primitives 普遍在 Ethereum 上还没有。